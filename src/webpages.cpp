/*
   webpages.cpp
 * (c)2025 Forward Computing and Control Pty. Ltd.
 * NSW Australia, www.forward.com.au
 * This code is not warranted to be fit for any purpose. You may only use it at your own risk.
 * This generated code may be freely used for both private and commercial use
 * provided this copyright is maintained.

*/

#include "webpages.h"
#include <NetworkClient.h>
#include <WebServer.h>
#include "LittleFSsupport.h"
#include "TZ_support.h"
#include "RTC_support.h"
#include "tzPosix.h"
#include "PrintTimes.h"
#include "DebugOut.h"

// These strings generated by Claude Code (AI) from three files containing the text from the webpages
// that Claude Code has already processed to move the %..% parameters to variables at the top of the .html files.
// Those files were then editied to cut out the header sections into .head files for Claude to process (below)
// and the remaining html code save in .tail files to be used by webpageProcessor.cpp

// the command to Claude Code was
/**
  For the three files settzRTC.head  index.head  setRTCtime.head

  Create a new file containing the contents of each as a separate String
  Use \n\ to continue the lines and escape the " with \"
  For example

  String head1 = "\
  <!DOCTYPE html>\n\
  <html>\n\

  etc
*/
// combined all the webpage vars into one header
const char* html_head = "\
<!DOCTYPE html>\n\
<html>\n\
  <script>\n\
    // Placeholder variables - will be replaced by server\n\
    const PLACEHOLDER_RESET_DATE_TIME = %RESET_DATE_TIME%;\n\
    const PLACEHOLDER_DATE = \"%DATE%\";\n\
    const PLACEHOLDER_TIME = \"%TIME%\";\n\
    const PLACEHOLDER_CUR_DATE = \"%CUR_DATE%\";\n\
    const PLACEHOLDER_TIME_CURRENT_S = %TIME_CURRENT_S%;\n\
    const PLACEHOLDER_HAVE_RTC = %HAVE_RTC%;\n\
    const PLACEHOLDER_TZ_STR = \"%TZ_STR%\";\n\
    const PLACEHOLDER_TZ_CORRECTED = \"%TZ_CORRECTED%\";\n\
    const PLACEHOLDER_TZ_DESC_STR = \"%TZ_DESC_STR%\";\n\
    const PLACEHOLDER_TZ_STR_SET_CORRECTED = \"%TZ_STR_SET_CORRECTED%\";\n\
  </script>";

extern time_t get_rtc_unix_time(); // from RTC_support
extern void setRTC(time_t sec); //only used by webpages.cpp

static WebServer server(80);

// normally DEBUG is commented out
//#define DEBUG
static Print* debugPtr = NULL;  // local to this file

static String processVars(const String& input); // edit this method to add values for % .. % variables
static void handle_setTZstr();
static void handle_resetTZ();
static void handle_setRTCDateTime();
static void handle_settzRTC();
static void handle_setRTCtime();
static void handleIndex();
static void printRequestArgs(Print *outPtr);
static void handleNotFound();
static bool loadFromFile(String path);
static void redirect(const char *url);
static void returnOK();
static void returnFail(String msg);
static bool getLocalTmRTC(tm* tmPtr);

static String correctedTZstr;  // empty if no problems
static String correctedTZstrDsc;
static String userInputTZstr;
static String webRtnMsg;
static bool resetDateTime = false; // set true when TZ changed cleared when Date/Time set

static String getLocalDateRTC_yyyymmdd();
static String getLocalTimeRTC_hhmm();
static uint32_t getLocalTimeRTC_s();

static uint8_t dayOfTheWeek(uint16_t year, uint8_t month, uint8_t day);



static bool webServerStarted = false;

void startWebServer() {
#ifdef DEBUG
  debugPtr = getDebugOut();
#endif
  if (webServerStarted) {
    return;
  }
  if (!initializeFS()) {
    if (debugPtr) {
      debugPtr->println("LittleFS failed to start.");
    }
  }

  server.on("/", HTTP_GET, handleIndex);
  server.on("/index.html", handleIndex); // both GET and POST, to handle redirect after set time
  server.on("/setRTCtime.html", handle_setRTCtime); // both GET and POST, to handle redirect after set time
  server.on("/settzRTC.html", handle_settzRTC); // both GET and POST, to handle redirect after setTZ
  server.on("/setRTCDateTime", HTTP_POST, handle_setRTCDateTime);
  server.on("/setTZstr", HTTP_GET, handle_setTZstr);
  server.on("/resetTZ", HTTP_GET, handle_resetTZ);

  server.onNotFound(handleNotFound);
  (void)(returnOK); // to suppress compiler warning only
  (void)(returnFail); // to suppress compiler warning only

  server.begin();
  if (debugPtr) {
    debugPtr->println("RTC web server started");
  }
  webServerStarted = true;
}

void handleWebServer() {
  startWebServer();
  server.handleClient();
}

static bool getLocalTmRTC(tm* tmPtr) {
  if (!tmPtr) {
    return false;
  }
  time_t t = get_rtc_unix_time();
  localtime_r(&t, tmPtr);
  return true;
}

// get current RTC date including current TZ
static String getLocalDateRTC_yyyymmdd() {
  struct tm tm_now;
  getLocalTmRTC(&tm_now);
  return get_yyyymmdd(&tm_now);
}

static String getLocalTimeRTC_hhmm() {
  struct tm tm_now;
  getLocalTmRTC(&tm_now);
  return getHHMM(&tm_now);
}

/*********
  // not used
  static uint32_t getLocalTimeRTC_mins();
  static String getLocalTimeRTC_hhmmss();

  static String getLocalTimeRTC_hhmmss() {
  struct tm tm_now;
  getLocalTmRTC(&tm_now);
  return getHHMMss(&tm_now);
  }

  //// local time in mins not used
  static uint32_t getLocalTimeRTC_mins() {
  struct tm tm_now;
  getLocalTmRTC(&tm_now);
  unsigned int rtn = (tm_now.tm_hour);
  rtn = rtn * 60 + tm_now.tm_min;
  return rtn;
  }
********/


//// local time HH:MM:ss in sec
static uint32_t getLocalTimeRTC_s() {
  struct tm tm_now;
  getLocalTmRTC(&tm_now);
  uint32_t rtn = (tm_now.tm_hour);
  rtn = rtn * 60 + tm_now.tm_min;
  rtn = rtn * 60 + tm_now.tm_sec;
  return rtn;
}

/**
   Converts date and time strings from a web POST request into a struct tm

   @param date_str The date string in format "YYYY-MM-DD"
   @param time_str The time string in format "HH:MM"
   @param tm_out Pointer to struct tm to store the result
   @return 0 on success, -1 on failure
*/
static bool convert_datetime_to_tm(const char *date_str, const char *time_str, struct tm * tm_out) {
  if (!date_str || !time_str || !tm_out) {
    return false;
  }

  // Initialize the struct tm to all zeros
  memset(tm_out, 0, sizeof(struct tm));

  // Parse the date string (YYYY-MM-DD)
  int year, month, day;
  if (sscanf(date_str, "%d-%d-%d", &year, &month, &day) != 3) {
    return false;
  }

  // Parse the time string (HH:MM)
  int hour, minute;
  if (sscanf(time_str, "%d:%d", &hour, &minute) != 2) {
    return false;
  }

  // Validate the input values
  if (year < 1900 || month < 1 || month > 12 || day < 1 || day > 31 ||
      hour < 0 || hour > 23 || minute < 0 || minute > 59) {
    return false;
  }

  // Fill in the struct tm
  tm_out->tm_year = year - 1900;  // Years since 1900
  tm_out->tm_mon = month - 1;     // Months since January (0-11)
  tm_out->tm_mday = day;          // Day of the month (1-31)
  tm_out->tm_hour = hour;         // Hours (0-23)
  tm_out->tm_min = minute;        // Minutes (0-59)
  tm_out->tm_sec = 0;             // Seconds set to 0
  tm_out->tm_isdst = -1; // check daylight saving settings

  tm_out->tm_wday = dayOfTheWeek(year, month, day); //(day + 13 * (m + 1) / 5 + k + k / 4 + j / 4 + 5 * j) % 7;

  return true;
}

/**
    returns the day of the week (Sunday == 0) for a given year,month,day
*/
static uint8_t dayOfTheWeek(uint16_t year, uint8_t month, uint8_t day) {
  // Calculate day of week (0-6, Sunday = 0)
  // Using Zeller's Congruence algorithm
  int y = (month < 3) ? (year - 1) : year;
  int m = (month < 3) ? (month + 12) : month;
  int k = y % 100;
  int j = y / 100;

  int wday = (day + 13 * (m + 1) / 5 + k + k / 4 + j / 4 + 5 * j) % 7;
  return wday;
}

/**
   Convert a local tm struct to Unix timestamp

   @param localTime The local time struct to convert
   @return Unix timestamp (seconds since Jan 1, 1970)
*/
time_t local_tm_to_unix_time(const struct tm* tm_local) {
  if (!tm_local) {
    return 0;
  }

  // Create a copy of the input tm struct to avoid modifying the original
  struct tm tm_copy;
  memcpy(&tm_copy, tm_local, sizeof(struct tm));

  // Use mktime which converts local time to Unix timestamp
  time_t timestamp = mktime(&tm_copy);

  return timestamp;
}

void setRTCtimeMsg(String &msg) {
  webRtnMsg = msg;
}

/**
   Process a variable name and return its replacement
   To be implemented based on specific variable needs
*/
String RTC_webVariableProcessor(const String& varName) {
#ifdef DEBUG
  debugPtr = &Serial;
#endif
  if (debugPtr) {
    debugPtr->print(" RTC_webVariableProcessor: ");
    debugPtr->print(varName);
  }
  String rtnString = "";

  if (varName == "DATE") {
    rtnString = getLocalDateRTC_yyyymmdd();

  } else if (varName == "TIME") {
    rtnString = getLocalTimeRTC_hhmm();

  } else if (varName == "CUR_DATE") {
    rtnString = getLocalDateRTC_yyyymmdd();

  } else if (varName == "TIME_CURRENT_S") {
    rtnString =  getLocalTimeRTC_s();

  } else if (varName == "HAVE_RTC") {
    rtnString = (isRTCDateTimeSet() ? "1" : "0");

  } else if (varName == "RESET_DATE_TIME") {
    rtnString = (resetDateTime ? "1" : "0");

  } else if (varName == "TZ_DESC") {
    String TZstr = getTZstr();
    struct posix_tz_data_struct tzdata;
    posixTZDataFromStr(TZstr, tzdata);
    buildPOSIXdescription(tzdata, rtnString);
    rtnString.replace("\n", "<br>");

  } else if (varName == "TZ_STR") {
    if (webRtnMsg.length()) {
      rtnString = correctedTZstr;
      correctedTZstr = ""; // finished  with this
    } else {
      rtnString = getTZstr();
    }

  } else if (varName == "TZ_DESC_STR") {
    if (correctedTZstrDsc.length()) {
      rtnString = correctedTZstrDsc;
      correctedTZstrDsc = ""; // finished  with this
    } else {
      rtnString = getTZstr();
    }
    String TZstr = rtnString;
    struct posix_tz_data_struct tzdata;
    posixTZDataFromStr(TZstr, tzdata);
    buildPOSIXdescription(tzdata, rtnString);
    rtnString.replace("\n", "<br>");

  } else if (varName == "TZ_CORRECTED") {
    if (userInputTZstr.length()) {
      rtnString = "Time Zone string has been cleaned up from<br>";
      rtnString += userInputTZstr;
      //   AEST-10AEDT,M10.1.0,M4.1.0/3
      rtnString += "<br>to";
      userInputTZstr = ""; // finished  with this
    }

  } else if (varName == "TZ_STR_SET_CORRECTED") {
    rtnString = webRtnMsg;
    webRtnMsg = "";

  } else {
    // Return empty string if not found
  }
  if (debugPtr) {
    debugPtr->print("   replaced with: ");
    debugPtr->println(rtnString);
  }
  return rtnString;
}


static void redirect(const char *url) {
  if (debugPtr) {
    debugPtr->print("Redirect to: ");    debugPtr->println(url);
  }
  server.sendHeader("Location", url);
  server.send(307);
}

static void returnOK() {
  if (debugPtr) {
    debugPtr->print("Return OK (empty plain text)");    debugPtr->println();
  }
  server.send(200, "text/plain", "");
}

static void returnFail(String msg) {
  msg += "\r\n";
  if (debugPtr) {
    debugPtr->print("Return Fail with msg: ");    debugPtr->println(msg);
  }
  server.send(500, "text/plain", msg);
}

static void printRequestArgs(Print * outPtr) {
  if (!outPtr) {
    return;
  }
  outPtr->print("URI: ");
  outPtr->print(server.uri());
  outPtr->print("   Method: ");
  outPtr->println((server.method() == HTTP_GET) ? "GET" : "POST");
  outPtr->print(" Arguments: ");
  outPtr->println(server.args());
  for (uint8_t i = 0; i < server.args(); i++) {
    outPtr->print(" NAME:");
    outPtr->print(server.argName(i));
    outPtr->print("   VALUE:");
    outPtr->println(server.arg(i));
  }
}

static void handleNotFound() {
  if (loadFromFile(server.uri())) {
    return;
  }
  if (debugPtr) {
    debugPtr->print("File Not found: ");    debugPtr->println(server.uri());
    printRequestArgs(debugPtr);
  }
  String message = "LittleFS \n\n";
  message += "URI: ";
  message += server.uri();
  message += "\nMethod: ";
  message += (server.method() == HTTP_GET) ? "GET" : "POST";
  message += "\nArguments: ";
  message += server.args();
  message += "\n";
  for (uint8_t i = 0; i < server.args(); i++) {
    message += " NAME:" + server.argName(i) + "\n VALUE:" + server.arg(i) + "\n";
  }
  server.send(404, "text/plain", message);
}

// for .css and static .html etc
static bool loadFromFile(String path) {
  if (debugPtr) {
    debugPtr->print("Load File: ");    debugPtr->println(path);
  }
  String dataType = "text/plain";
  if (path.endsWith("/")) {
    path += "index.html";
  }

  if (path.endsWith(".html")) {
    dataType = "text/html";
  } else if (path.endsWith(".css")) {
    dataType = "text/css";
  }

  File dataFile = LittleFS.open(path.c_str());

  if (!dataFile) {
    if (debugPtr) {
      debugPtr->print(" Failed to open: ");    debugPtr->println(path);
    }
    return false;
  }

  if (server.streamFile(dataFile, dataType) != dataFile.size()) {
    if (debugPtr) {
      debugPtr->print(" Sent less data than expected from file: ");    debugPtr->println(path);
    }
  }

  dataFile.close();
  return true;
}

static void sendHeaderAndTail(String & header, const char*tailPath) {
  if (debugPtr) {
    debugPtr->print(" sendHeaderAndTail.  tail File: "); debugPtr->println(tailPath);
    debugPtr->println(" header:-------- "); debugPtr->println(header);
    debugPtr->println(" ======= ");
  }
  File dataFile = LittleFS.open(tailPath);

  if (!dataFile) {
    Serial.print(" Failed to open:"); Serial.println(tailPath);
    return;
  }

  size_t fileSize = dataFile.size();
  NetworkClient currentClient = server.client();
  server.setContentLength(fileSize + header.length());
  String contentType = "text/html";
  const int code = 200;
  server.send(code, contentType, "");
  size_t headerSent = currentClient.write(header.c_str(), header.length());
  (void)(headerSent);
  size_t dataSent = currentClient.write(dataFile);
  if (dataSent != dataFile.size()) {
    if (debugPtr) {
      debugPtr->print(" Sent less data than expected from file: ");    debugPtr->println(tailPath);
    }
  }
  dataFile.close();
}

void resetRTC_TZ() {
  resetDefaultTZstr();
  saveTZconfigIfNeeded(); // write to file
  resetDateTime = true;
}

static void handle_resetTZ() {
  resetRTC_TZ();
  redirect("/setRTCtime.html");
}

static void handle_settzRTC() {
  String newHeader = processVars(html_head);
  sendHeaderAndTail(newHeader, "/settzRTC.tail");
}


static void handle_setRTCtime() {
  String newHeader = processVars(html_head);
  sendHeaderAndTail(newHeader, "/setRTCtime.tail");
}


static void handleIndex() {
  String newHeader = processVars(html_head);
  sendHeaderAndTail(newHeader, "/index.tail");
}

void setRTC_DateTime(String &dateArg, String &timeArg) {
  if ((dateArg.length() == 0) || (timeArg.length() == 0)) {
    if (debugPtr) {
      debugPtr->print(" Error missing DATE or TIME arg");    debugPtr->println();
    }
    return;
  }
  struct tm tm_now;
  if (! convert_datetime_to_tm(dateArg.c_str(), timeArg.c_str(), &tm_now)) {
    if (debugPtr) {
      debugPtr->print(" Error in DATE or TIME format");    debugPtr->println();
    }
    return;
  }
  print_tm(&tm_now, debugPtr);
  // now convert to unix time using current TZ
  time_t unixTime = local_tm_to_unix_time(&tm_now);
  setRTC(unixTime);
  struct tm rtcNow;
  getLocalTmRTC(&rtcNow);

  if (debugPtr) {
    debugPtr->print("  RTC is now ");
    print_tm(&rtcNow, debugPtr);
  }
  resetDateTime = false;
}

//URI: /setRTC_DateTime Method: POST
//Arguments: 2
// NAME:DATE VALUE:2025-03-21
// NAME:TIME VALUE:10:00
static void handle_setRTCDateTime() {
  if (debugPtr) {
    debugPtr->print(" handle_setRTCDateTime ");    debugPtr->println();
    printRequestArgs(debugPtr);
  }

  if (server.args() != 2) {
    if (debugPtr) {
      debugPtr->print(" handle_setRTCDateTime args not 2 ");    debugPtr->println();
    }
    return;
  }
  String dateArg = server.arg("DATE");
  String timeArg = server.arg("TIME");
  setRTC_DateTime(dateArg, timeArg);
  redirect("/index.html");
}

// returns false for redirect("/settzRTC.html")
// returns true for redirect("/setRTCtime.html");
bool setRTC_TZstr(String &tzArg) {
  if ((tzArg.length() == 0)) {
    if (debugPtr) {
      debugPtr->print(" Error missing TZ_INPUT_STR");    debugPtr->println();
    }
    webRtnMsg = "Time Zone input is empty";
    return false;
  }

  String msg;
  tzArg.trim();
  String cleanStr = tzArg;
  cleanUpPosixTZStr(cleanStr);
  if (tzArg != cleanStr) {
    userInputTZstr = tzArg;
    correctedTZstr = cleanStr;
    correctedTZstrDsc = cleanStr;
    webRtnMsg = "Select the Set TZ String button again to set<br>this cleaned up time zone string";
    if (debugPtr) {
      debugPtr->println(webRtnMsg);
      debugPtr->print(" Cleaned up TZ: "); debugPtr->println(cleanStr);
    }
    return false;
    //redirect("/settzRTC.html");
  } //else {
  correctedTZstrDsc = cleanStr;
  if (debugPtr) {
    debugPtr->print("  TZ is now "); debugPtr->println(cleanStr);
  }
  // set new tz
  setTZfromPOSIXstr(cleanStr.c_str()); // cleans up and set save flag as well
  resetDateTime = true;
  saveTZconfigIfNeeded(); // write to file
  return true;
  //redirect("/setRTCtime.html");
}


//URI: /setTZstr Method: POST
//Arguments: 1
// NAME:TZ_INPUT_STR   VALUE:UTC
static void handle_setTZstr() {
  if (debugPtr) {
    debugPtr->print(" handle_setTZstr ");    debugPtr->println();
    printRequestArgs(debugPtr);
  }

  if (server.args() != 1) {
    if (debugPtr) {
      debugPtr->print(" handle_setTZstr args not 1 ");    debugPtr->println();
    }
    return;
  }

  // returns false for redirect("/settzRTC.html")
  // returns true for redirect("/setRTCtime.html");
  String tzArg = server.arg("TZ_INPUT_STR");
  if (setRTC_TZstr(tzArg)) {
    redirect("/setRTCtime.html");
  } else {
    redirect("/settzRTC.html");
  }
}

/**
   Process a string containing variables delimited by %...%
   Replaces each variable with its processed value
*/
static String processVars(const String & input) {
  //static bool tzUpdated = false;
  if (input.length() == 0) {
    return input;
  }
  String result = "";
  unsigned int currentPos = 0;
  int startVarPos;
  int endVarPos;
  if (debugPtr) {
    debugPtr->println("Processing variables in string");
  }
  while (currentPos < input.length()) {
    startVarPos = input.indexOf('%', currentPos);

    if (startVarPos == -1) {
      // No more variables found
      result += input.substring(currentPos);
      break;
    }

    // Add text before the variable
    result += input.substring(currentPos, startVarPos);

    // Find the closing % for the variable
    endVarPos = input.indexOf('%', startVarPos + 1);

    if (endVarPos == -1) {
      // No closing % found, treat as normal text
      result += "%";
      Serial.println("Unclosed % found");
      currentPos = startVarPos + 1;
      continue;
    }

    // Extract the variable name
    String varName = input.substring(startVarPos + 1, endVarPos);
    if (debugPtr) {
      debugPtr->print(" Found variable: "); debugPtr->print(varName);
    }

    // Process the variable and add its replacement
    String replacement = RTC_webVariableProcessor(varName);
    if (debugPtr) {
      debugPtr->print("  Replaced with: "); debugPtr->println(replacement);
    }
    result += replacement;

    // Move past this variable
    currentPos = endVarPos + 1;
  }

  if (debugPtr) {
    debugPtr->println("Variable processing complete");
  }
  return result;
}
